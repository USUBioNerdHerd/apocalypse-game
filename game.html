<html>

<head>
<script data-require="angular.js@*" data-semver="1.3.1" src="//code.angularjs.org/1.3.1/angular.js"></script>
<script src="rounding.js"></script>
</head>

<body>

  <p>The game...</p>
  <canvas width="500" height="500"></canvas>

  <script>

  // would be nice to use this or something like it later
  // stolen from https://gist.github.com/winduptoy/8b5c574e0e33bf547a31
  function roundCorners(path,radius) {
  	var segments = path.segments.slice(0);
  	path.removeSegments();

  	for(var i = 0, l = segments.length; i < l; i++) {
  		var curPoint = segments[i].point;
  		var nextPoint = segments[i + 1 == l ? 0 : i + 1].point;
  		var prevPoint = segments[i - 1 < 0 ? segments.length - 1 : i - 1].point;
  		var nextDelta = curPoint.subtract(nextPoint);
  		var prevDelta = curPoint.subtract(prevPoint);

  		nextDelta.length = radius;
  		prevDelta.length = radius;

  		path.add(
  			new paper.Segment(
  				curPoint.subtract(prevDelta),
  				null,
  				prevDelta.divide(2)
  			)
  		);

  		path.add(
  			new paper.Segment(
  				curPoint.subtract(nextDelta),
  				nextDelta.divide(2),
  				null
  			)
  		);
  	}
  	path.closed = true;
  	return path;
  }



  var canvas = document.querySelector("canvas");
  var context = canvas.getContext("2d");
  context.fillStyle = "red";
  context.fillRect(10, 10, 100, 50);

  var boxes = document.querySelector("canvas").getContext("2d");
  boxes.strokeStyle = "blue";
  boxes.strokeRect(10, 100, 50, 50);
  boxes.lineWidth = 5;
  boxes.strokeRect(100, 100, 50, 50);
  context.fillStyle = "yellow";
  context.fillRect(100, 100, 50, 50);

  var lines = document.querySelector("canvas").getContext("2d");
  lines.beginPath();
  for (var y = 200; y < 300; y += 10) {
    lines.strokeStyle = "green";
    lines.moveTo(10, y);
    lines.lineTo(90, y);
  }
  lines.stroke();


  //var color_array = ["yellow", "black", "#FF1210", "green", "blue", "blue", "green", "green", "green", "green"];
  //var i = 0;
  //for (var y = 400; y < 450; y += 10) {
  //  var color_lines = document.querySelector("canvas").getContext("2d");
  //  color_lines.strokeStyle = color_array[i];
  //  color_lines.beginPath();
  //  color_lines.moveTo(10, y);
  //  color_lines.lineTo(90, y);
  //  document.write(color_array[i]);
  //  lines.stroke();
  //  i = i + 1;
  //}



  //var backdrop = canvas.getContext("2d");
  //backdrop.fillStyle = "brown";
  //context.fillRect(0, 0, 500, 500);

function drawPoly(coords, color, label_text, label_coords, label_color = "white") {
  var poly = coords;
  //var poly=[ 105,105, 200,150, 150,200, 110,190 ];
  var ctx = canvas.getContext('2d');
  ctx.fillStyle = color;

  ctx.beginPath();
  ctx.moveTo(poly[0], poly[1]);
  for( item=2 ; item < poly.length-1 ; item+=2 ){ctx.lineTo( poly[item] , poly[item+1] )}

  ctx.closePath();
  ctx.fill();

  var labels = canvas.getContext("2d");
  labels.fillStyle = label_color;
  labels.font = "20px Arial";
  labels.textAlign = "center";
  labels.fillText(label_text, label_coords[0], label_coords[1]);

}

// background
var backdrop = canvas.getContext("2d");
backdrop.fillStyle = "purple";
context.fillRect(0, 0, 500, 500);

// city
drawPoly([ 10,10, 10,70, 80,120, 150,90, 160,40 ] ,"black", "City", [80, 70], "red");

// farm
drawPoly([ 490,490, 480,270, 300,300, 270,460, 400,490 ] ,"orange", "Farm", [400, 400]);

// forest
drawPoly([ 10,490, 200,460, 200,200, 50,300, 10,450 ] ,"green", "Forest", [80, 370]);

// river
drawPoly([ 500,0, 450,0, 230,200, 220,500, 270,500, 270,270, 500,50 ] ,"blue", "River", [350, 150]);


  // incorporating this in to apocalypse game

  class Display {

  // Draw current game state to screen
      draw(forest_hp, city_hp, farm_hp, river_hp, ) {

         // load in ~~constant~~ parameters for:
         // dimensions of screen
         // boundaries of polygons for forest, city, farm, river
         // animation parameters, eg. frame rate, wiggle amount
         // sprites?

         // draw background layer

         // draw each of 4 polygons

         // display sprite
         // determine position of sprite depending on frame
         // * alternatively, we could have multiple sprites instead of moving them
         // ** or, we should do both: moving, changing sprites

         // we need a function to define position and/or update sprite based on frame

         // pass frame to next iteration of draw()
         // alternatively, frame count be saved globally

      }

  }



  </script>

</body>

</html>
